/// Generated By XFlutter Cli.
///
/// more info: https://xflutter-cli.aghiadodeh.com
///
/// state management for UI
///
/// store and manage your liveData in [TransactionsParams].
import 'dart:async';
import 'dart:io';

import 'package:animated_infinite_scroll_pagination/animated_infinite_scroll_pagination.dart';
import 'package:dio/dio.dart';
import 'package:easy_localization/easy_localization.dart';
import 'package:lazy_evaluation/lazy_evaluation.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:tahsaldar/extensions/data_extension.dart';
import 'package:tahsaldar/models/data/payment/payment.dart';
import 'package:tahsaldar/models/ui_models/ui_message.dart';
import 'package:tahsaldar/network/config/env.dart';
import 'package:tahsaldar/viewmodels/base_viewmodel.dart';

import '../../../../config/instance_config.dart';
import '../../../../extensions/date_extension.dart';
import '../../../../repositories/payment_repository.dart';
import '../../../../utils/path_utils.dart';
import "transactions_params.dart";

class TransactionsViewModel extends BaseViewModel with PaginationViewModel<Payment> {
  final _params = Lazy(() => TransactionsParams());
  TransactionsParams get params => _params.value;

  final _paymentRepository = Lazy(() => PaymentRepository());
  PaymentRepository get paymentRepository => _paymentRepository.value;

  @override
  onInit() {
    super.onInit();
    getTotalPaid();
    listen();
    getPaginationList();
  }

  @override
  void onDispose() {
    dispose();
    super.dispose();
  }

  getTotalPaid() {
    callHttpRequest(
      () => paymentRepository.getTotal(month: params.month.value.number, year: params.year.value.toInteger()),
      loading: baseParams.loading,
      callback: (response) {
        if (response != null) {
          params.totalPaid.postValue(response);
        }
      },
    );
  }

  @override
  bool areItemsTheSame(Payment a, Payment b) => a.id == b.id;

  @override
  Future<void> fetchData(int page) async {
    final total = await paymentRepository.getAllTransactions(page);
    // tell the view-model the total of items.
    // this will stop loading more data when last data-chunk is loaded
    setTotal(total);
    params.zeroTransactions.postValue(total == 0);
  }

  @override
  Stream<PaginationState<List<Payment>>> streamSubscription() {
    return paymentRepository.result;
  }

  downloadExcelFile() async {
    baseParams.loading.postValue(true);
    // storage permission
    try {
      final status = await Permission.storage.status;
      if (status.isGranted) {
        await downloadFromApi();
      } else {
        Permission.storage.request().whenComplete(() async {
          await downloadFromApi();
        });
      }
    } catch (_) {
      baseParams.loading.postValue(false);
    }

    baseParams.loading.postValue(false);
  }

  downloadFromApi() async {
    final dio = findInstance<Dio>();
    String? saveDirectory = await getDownloadPath();
    final filename = 'transactions_${DateTime.now().millisecondsSinceEpoch}';

    if (saveDirectory != null) {
      saveDirectory = '$saveDirectory/$filename.xlsx';
    }

    File file = File(saveDirectory ?? '');

    file.create(recursive: true);
    var response = await dio.get(Env.excelDownloadLink, options: Options(responseType: ResponseType.bytes));

    if (response.data != null) {
      try {
        await file.writeAsBytes(response.data);
        baseParams.uiMessage.postValue(UiMessage(message: response.statusCode == 200 ? 'excel_file_downloaded'.tr() : 'issue_occurred_while_downloading'.tr()));
      } catch (e) {
        baseParams.uiMessage.postValue(UiMessage(message: e.toString()));
      }
    }
  }

  addItemToList(Payment payment, int index) => insertItem(index, payment, paginationParams.page);

  deleteTransaction(String id) async {
    callHttpRequest(
      () => paymentRepository.cancel(id),
      loading: baseParams.loading,
      callback: (response) async {
        if (response != null) {
          final index = paginationParams.itemsList.value.items.indexWhere((element) => element.item.id.toString() == id);
          deleteItem(index);
          addItemToList(response, index);
          getTotalPaid();
        }
      },
    );
  }
}
